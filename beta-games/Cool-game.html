<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>My 3D World</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Courier New, monospace; background: #000; color: #0f0; overflow: hidden; height: 100vh; }
        #container { width: 100%; height: 100vh; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; }
        #crosshair::before, #crosshair::after { content: ""; position: absolute; background: #0f0; }
        #crosshair::before { left: 50%; top: 0; width: 2px; height: 100%; transform: translateX(-50%); }
        #crosshair::after { top: 50%; left: 0; width: 100%; height: 2px; transform: translateY(-50%); }
        #info { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,.9); padding: 15px; border-radius: 4px; font-size: 13px; border: 1px solid #0f0; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="crosshair"></div>
    <div id="info">
        <strong>FIRST PERSON MODE</strong><br>
        • WASD to move<br>
        • SPACE to jump<br>
        • SHIFT to crouch<br>
        • Mouse to look around
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="/return-button.js?v=1"></script>
    <script>
        document.addEventListener("contextmenu", e => e.preventDefault());
        document.addEventListener("keydown", e => {
            if (e.keyCode === 123 || (e.ctrlKey && e.shiftKey && (e.keyCode === 73 || e.keyCode === 74)) || (e.ctrlKey && e.keyCode === 85)) {
                e.preventDefault();
                return false;
            }
        });

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const skyboxType = "none";
        if (skyboxType === "day") {
            const canvas = document.createElement("canvas");
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext("2d");
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, "#87CEEB");
            gradient.addColorStop(0.5, "#B0E0E6");
            gradient.addColorStop(1, "#E0F6FF");
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 300;
                const w = 60 + Math.random() * 80;
                const h = 30 + Math.random() * 20;
                ctx.beginPath();
                ctx.ellipse(x, y, w/2, h/2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.ellipse(x + w/3, y - h/3, w/3, h/3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.ellipse(x - w/3, y - h/4, w/4, h/4, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            const materials = [];
            for (let i = 0; i < 6; i++) {
                materials.push(new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide }));
            }
            const skyGeo = new THREE.BoxGeometry(500, 500, 500);
            const skyMesh = new THREE.Mesh(skyGeo, materials);
            scene.add(skyMesh);
        } else if (skyboxType === "space") {
            const canvas = document.createElement("canvas");
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext("2d");
            ctx.fillStyle = "#000011";
            ctx.fillRect(0, 0, 512, 512);
            for (let i = 0; i < 200; i++) {
                ctx.fillStyle = "rgba(255, 255, 255, " + Math.random() + ")";
                ctx.fillRect(Math.random() * 512, Math.random() * 512, 2, 2);
            }
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            const materials = [];
            for (let i = 0; i < 6; i++) {
                materials.push(new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide }));
            }
            const skyGeo = new THREE.BoxGeometry(500, 500, 500);
            const skyMesh = new THREE.Mesh(skyGeo, materials);
            scene.add(skyMesh);
        } else if (skyboxType === "city") {
            const canvas = document.createElement("canvas");
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext("2d");
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, "#001122");
            gradient.addColorStop(1, "#003344");
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = "#001100";
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * 512;
                const height = 100 + Math.random() * 150;
                const width = 20 + Math.random() * 40;
                ctx.fillRect(x, 512 - height, width, height);
                ctx.fillStyle = "#ffff00";
                for (let j = 0; j < height / 20; j++) {
                    if (Math.random() > 0.3) {
                        ctx.fillRect(x + 5, 512 - height + j * 20 + 5, 5, 8);
                    }
                }
                ctx.fillStyle = "#001100";
            }
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            const materials = [];
            for (let i = 0; i < 6; i++) {
                materials.push(new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide }));
            }
            const skyGeo = new THREE.BoxGeometry(500, 500, 500);
            const skyMesh = new THREE.Mesh(skyGeo, materials);
            scene.add(skyMesh);
        }

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2.5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById("container").appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        const gridHelper = new THREE.GridHelper(100, 100, 0x00ff00, 0x003300);
        scene.add(gridHelper);

        const blockData = [{"x":0,"y":0,"z":0,"color":"#ff4444","shape":"cube"},{"x":1,"y":0,"z":0,"color":"#44ff44","shape":"cube"},{"x":0,"y":0,"z":1,"color":"#4444ff","shape":"cube"},{"x":1,"y":1,"z":0,"color":"#ffff44","shape":"cube"},{"x":3,"y":0,"z":0,"color":"#ff4444","shape":"cube"},{"x":-2,"y":0,"z":5,"color":"#ff4444","shape":"cube"},{"x":11,"y":0,"z":2,"color":"#ff4444","shape":"cube"},{"x":4,"y":0,"z":7,"color":"#ff4444","shape":"cube"},{"x":3,"y":0,"z":-3,"color":"#ff4444","shape":"cube"},{"x":-3,"y":0,"z":7,"color":"#ff4444","shape":"cube"},{"x":5,"y":0,"z":-10,"color":"#ff4444","shape":"cube"},{"x":5,"y":0,"z":3,"color":"#ff4444","shape":"cube"},{"x":3,"y":0,"z":8,"color":"#ff4444","shape":"cube"},{"x":-4,"y":0,"z":-8,"color":"#ff4444","shape":"cube"},{"x":-4,"y":0,"z":-7,"color":"#ff4444","shape":"cube"},{"x":-4,"y":1,"z":-7,"color":"#ff4444","shape":"cube"},{"x":-3,"y":1,"z":-7,"color":"#ff4444","shape":"cube"},{"x":-3,"y":1,"z":-6,"color":"#ff4444","shape":"cube"},{"x":-2,"y":1,"z":-6,"color":"#ff4444","shape":"cube"},{"x":-2,"y":1,"z":-5,"color":"#ff4444","shape":"cube"},{"x":-2,"y":2,"z":-5,"color":"#ff4444","shape":"cube"},{"x":-1,"y":2,"z":-5,"color":"#ff4444","shape":"cube"},{"x":-1,"y":2,"z":-4,"color":"#ff4444","shape":"cube"},{"x":-1,"y":3,"z":-4,"color":"#ff4444","shape":"cube"},{"x":-1,"y":3,"z":-3,"color":"#ff4444","shape":"cube"},{"x":-3,"y":2,"z":-7,"color":"#ff4444","shape":"cube"},{"x":-3,"y":3,"z":-7,"color":"#ff4444","shape":"cube"},{"x":-3,"y":4,"z":-7,"color":"#ff4444","shape":"cube"},{"x":-3,"y":5,"z":-7,"color":"#ff4444","shape":"cube"},{"x":-3,"y":6,"z":-7,"color":"#ff4444","shape":"cube"},{"x":-3,"y":6,"z":-6,"color":"#ff4444","shape":"cube"},{"x":23,"y":0,"z":21,"color":"#ff4444","shape":"cube"},{"x":23,"y":1,"z":21,"color":"#ff4444","shape":"cube"},{"x":24,"y":1,"z":21,"color":"#ff4444","shape":"cube"},{"x":23,"y":2,"z":21,"color":"#ff4444","shape":"cube"},{"x":24,"y":2,"z":21,"color":"#ff4444","shape":"cube"},{"x":24,"y":2,"z":22,"color":"#ff4444","shape":"cube"},{"x":23,"y":3,"z":21,"color":"#ff4444","shape":"cube"},{"x":23,"y":3,"z":22,"color":"#ff4444","shape":"cube"},{"x":23,"y":4,"z":22,"color":"#ff4444","shape":"cube"},{"x":24,"y":4,"z":22,"color":"#ff4444","shape":"cube"},{"x":23,"y":5,"z":22,"color":"#ff4444","shape":"cube"}];
        const worldBlocks = [];
        
        blockData.forEach(data => {
            if (data.color === "#00ff00") return;
            
            let geometry;
            switch(data.shape) {
                case "sphere": geometry = new THREE.SphereGeometry(0.5, 16, 16); break;
                case "cylinder": geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16); break;
                case "cone": geometry = new THREE.ConeGeometry(0.5, 1, 16); break;
                case "pyramid": geometry = new THREE.ConeGeometry(0.5, 1, 4); break;
                default: geometry = new THREE.BoxGeometry(1, 1, 1);
            }
            
            const material = new THREE.MeshStandardMaterial({ color: data.color, roughness: 0.7, metalness: 0.2 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(data.x, data.y, data.z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            worldBlocks.push(mesh);
        });

        const playerHeight = 1.7;
        const playerRadius = 0.3;
        let velocity = new THREE.Vector3();
        let isGrounded = false;
        let isCrouching = false;
        const gravity = -0.02;
        const jumpStrength = 0.3;
        const moveSpeed = 0.1;
        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false };

        function checkCollision(pos, radius, height) {
            const playerBox = new THREE.Box3(
                new THREE.Vector3(pos.x - radius, pos.y - height, pos.z - radius),
                new THREE.Vector3(pos.x + radius, pos.y, pos.z + radius)
            );
            for (let block of worldBlocks) {
                if (playerBox.intersectsBox(new THREE.Box3().setFromObject(block))) {
                    return block;
                }
            }
            return null;
        }

        function updatePlayer() {
            const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
            const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));
            const moveDir = new THREE.Vector3();
            
            if (keys.w) moveDir.add(forward);
            if (keys.s) moveDir.sub(forward);
            if (keys.a) moveDir.sub(right);
            if (keys.d) moveDir.add(right);
            
            if (moveDir.length() > 0) moveDir.normalize();
            
            isCrouching = keys.shift;
            const currentHeight = isCrouching ? playerHeight * 0.6 : playerHeight;
            
            const newPosX = camera.position.clone();
            newPosX.x += moveDir.x * moveSpeed;
            if (!checkCollision(newPosX, playerRadius, currentHeight)) {
                camera.position.x = newPosX.x;
            }
            
            const newPosZ = camera.position.clone();
            newPosZ.z += moveDir.z * moveSpeed;
            if (!checkCollision(newPosZ, playerRadius, currentHeight)) {
                camera.position.z = newPosZ.z;
            }
            
            velocity.y += gravity;
            
            const newPosY = camera.position.clone();
            newPosY.y += velocity.y;
            
            const collision = checkCollision(newPosY, playerRadius, currentHeight);
            if (collision && velocity.y <= 0) {
                const blockTop = collision.position.y + 0.5;
                camera.position.y = blockTop + currentHeight;
                velocity.y = 0;
                isGrounded = true;
            } else {
                camera.position.y += velocity.y;
                if (camera.position.y > newPosY.y - 0.1 && camera.position.y < newPosY.y + 0.1) {
                    isGrounded = false;
                }
            }
            
            if (camera.position.y < -10) {
                camera.position.set(0, 2.5, 0);
                velocity.y = 0;
            }
            
            if (keys.space && isGrounded) {
                velocity.y = jumpStrength;
                isGrounded = false;
            }
            
            camera.rotation.order = "YXZ";
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
        }

        window.addEventListener("keydown", e => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = true;
            if (e.key === " ") keys.space = true;
            if (e.key === "Shift") keys.shift = true;
        });

        window.addEventListener("keyup", e => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = false;
            if (e.key === " ") keys.space = false;
            if (e.key === "Shift") keys.shift = false;
        });

        let pitch = 0, yaw = 0;
        
        renderer.domElement.addEventListener("click", () => {
            renderer.domElement.requestPointerLock();
        });

        document.addEventListener("mousemove", e => {
            if (document.pointerLockElement === renderer.domElement) {
                const movementX = e.movementX || 0;
                const movementY = e.movementY || 0;
                yaw -= movementX * 0.002;
                pitch -= movementY * 0.002;
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            }
        });

        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
